---
layout:     post
title:      面试
subtitle:   面试笔记
date:       2021-03-01
author:     南三号
header-img: img/css.jpg
catalog: true
tags:
    - 面试
    - 前端
---

### 网络

- http和https
- Tcp连接，三次握手，四次挥手
- 跨域解决方案：Window.postMessage(dom查询)，document.domain（子域父域），代理，CROS（跨资源共享），JSONP

### Javascript

- node

  - express和koa的中间件原理

- 微信小程序JS Bridge

- 六种原型：Boolean Undefined String Symbol Null Number。（一种object型，六中基本类型，一种复杂类型）

- [js的预编译](https://juejin.im/post/5aa6693df265da23884cb571)

- [异步加载js文件](https://www.jianshu.com/p/bf8b5bf5fc90)

- 确定一个对象的类型

  JavaScript有五种方法可以确定一个值到底是什么类型，分别是typeof运算符，constructor法，instanceof运算符，Object.prototype.toString方法以及Array.isArray法. 
  
- 定时器函数：setInterval的一下运行两次。

- 箭头函数和普通函数的差别：

  - 箭头函数不绑定this
  - 无argument，rest代替
  - 不能使用new操作符
  - 没有原型属性
  - 不能简单返回对象字面量
  
- 优先级 （）和 . 大于 new

- 正则表达式

- 事件捕获与事件冒泡（addEventListener的第三个参数），事件委托

- 原型：原型是一个**对象**，其他对象可以通过它实现继承 

  - 实例方法，原型方法，静态方法

  - 寄生组合继承与Class继承
  - 原型链：![](https://segmentfault.com/img/bVmPdk)

- `===`与`==`的区别，`==`的源码

- for in 与for of（Iterator迭代器）的区别

- 实体字符

- [webpack原理](https://juejin.cn/post/6844903614469636103)：先合并命令行参数和配置文件参数，然后根据参数从入口文件开始编译，在编译时可以通过对module的配置，对不同文件进行编译输出，不同的loader是链式调用，即以前一个loader的输出为输入。在编译的过程中会触发一系列的事件，加载的插件通过监听这些事件对编译结果进行修改。编译过程中会形成引用关系的树，然后对各个模块形成chunk，最后打包到一个文件中去，然后输出文件

- babel（将Es6转为Es5）原理：通过对语法分析后产生的抽象语法树进行结构替换

- 手写Promise的`.all`，`.race`，`any`，`allSettled`

### CSS

- 盒子模型：标准盒模型和替代盒模型（IE）
- [BFC](https://zhuanlan.zhihu.com/p/25321647)，应用：清除浮动，防止边距折叠，两栏布局
- float不是完全脱离文档流，float只是脱离了文档流的dom空间但是还占据着文字空间。
- 移动端适配，dpr
- [css引擎解析过程](http://jartto.wang/2017/11/13/Exploring-the-principle-of-CSS-parsing/)
- [相邻的两个inline-block节点为什么会出现间隔](https://www.zhangxinxu.com/wordpress/2012/04/inline-block-space-remove-%E5%8E%BB%E9%99%A4%E9%97%B4%E8%B7%9D/)：inline-block元素之间出现空格的原因： html 元素换行 ，可以通过去掉换行或者将父元素的font-size设置为0
- 浏览器 CSS 匹配核心算法的规则是以`从右向左`方式匹配节点的 
- 选择器优先级：内联样式 > ID 选择器 > 类选择器 = 属性选择器 = 伪类选择器 > 标签选择器 = 伪元素选择器 
- Css实现一个三角形
- grid布局，flex布局
- [css继承](https://www.jianshu.com/p/34044e3c9317)

### HTML

- 行内元素，块级元素

  1. 块属性标签的宽度假如不做设置，会直接默认为父元素宽度的100%
  2. p标签中不能嵌套div标签
- 替换元素（input，img，iframe，video，canvas）：替换元素是浏览器根据其标签的元素与属性来判断显示具体的内容。


### 浏览器：

- 触发重绘和重排（回流）：

  添加、删除、更新 DOM 节点
  通过 display: none 隐藏一个 DOM 节点-触发重排和重绘
  通过 visibility: hidden 隐藏一个 DOM 节点-只触发重绘，因为没有几何变化
  移动或者给页面中的 DOM 节点添加动画
  添加一个样式表，调整样式属性
  用户行为，例如调整窗口大小，改变字号，或者滚动。

- [预加载与懒加载](https://juejin.im/post/5b0c3b53f265da09253cbed0)

- coockie和session的区别

- event loop，调用栈，任务队列，微任务队列

  **macrotasks**: `setTimeout, setInterval, setImmediate, I/O, UI rendering` **microtasks**: `process.nextTick, Promise, MutationObserver` 

- Bom对象：

  Navagator：提供有关浏览器的信息

  Window：Window对象处于对象层次的最顶层，它提供了处理Navagator窗口的方法和属性

  Location：提供了与当前打开的URL一起工作的方法和属性，是一个静态的对象

  History：提供了与历史清单有关的信息

  Document：包含与文档元素一起工作的对象，它将这些元素封装起来供编程人员使用
  
- 可获得焦点的元素： 

  1. window
  2. 链接被点击或键盘操作
  3. 表单空间被点击或键盘操作
  4. 设置`tabindex`属性的元素被点击或键盘操作
  
- [浏览器缓存机制](https://juejin.im/post/5b3c87386fb9a04f9a5cb037)：浏览器的缓存机制也就是我们说的HTTP缓存机制，其机制是根据HTTP报文的缓存标识进行的，浏览器缓存有 **HTML Meta 标签控制**与 **HTTP 头信息控制**两种。头信息控制关键字段：**Expires** 和 **Cache-Control** 

  - 强制缓存
  - 协商缓存

### VUE

- 双向绑定
- computed与watch还有filter的区别

### 其他

- 前端安全问题：XSS（跨站脚本攻击），CSRF（跨域请求伪造）

- hyberid混合开发，多端开发

- 前端优化的三个维度：静态资源优化、接口访问优化、页面渲染速度优化。

  常见的方式：减少 HTTP 请求数，减少 DNS 查询，使用 CDN，避免重定向，图片懒加载，减少 DOM 元素数量，减少 DOM 操作，使用外部 JavaScript 和 CSS，压缩 JavaScript 、 CSS 、字体、图片等，优化 CSS Sprite，使用 iconfont，字体裁剪，多域名分发划分内容到不同域名，尽量减少 iframe 使用，避免图片 src 为空，把样式表放在 中，把脚本放在页面底部

- 常用的存储：

  浏览器端：cookie，WebStorage(localStorage、sessionStorage)，userData，indexedDB

  服务器端：session

- iframe可用在以下几个场景中：

  1：典型系统结构，左侧是功能树，右侧就是一些常见的table或者表单之类的。为了每一个功能，单独分离出来，采用iframe。 
  2：ajax上传文件。 
  3：加载别的网站内容，例如google广告，网站流量分析。

  4： 在上传图片时，不用flash实现无刷新。

  5： 跨域访问的时候可以用到iframe，使用iframe请求不同域名下的资源。
  
- [渐进增强VS 优雅降级](https://www.jianshu.com/p/d313f1108862) 

### 算法题：

- 动态规划，回溯，深度优先，广度优先

- 大数相加

- 数组去重

- 各种排序算法：[各种排序的特点](https://blog.csdn.net/tanggao1314/article/details/50667762)

- 快速排序：

  ```js
  var sortArray = function(nums) {
      // 快速排序
      function quickSort(start, end, arr) {
          if (start < end) {
              let mid = sort(start, end, arr);
              // 注意，一定要是 start mid , mid+1 end 这种组合
              // 否则当首位最大的时候(mid返回0)，将会无限循环
              quickSort(start, mid, arr);
              quickSort(mid+1, end, arr);
          }
          return arr;
      }
  
      function sort(start, end, arr) {
          // 取基准值
          let base = arr[start];
  
          let low = start;
          let high = end;
  
          while(low !== high) {
              // 从后往前，寻找比基准值小的值，赋给low位置(也就是取base值的位置)
              while(arr[high] >= base && high > low) {
                  high--;
              }
              arr[low] = arr[high];
              // 从前往后，寻找比基准值大的值，赋给high位置
              while(arr[low] <= base && high > low) {
                  low++;
              }
              arr[high] = arr[low];
          }
          arr[low] = base;
          return low;
      }
      return quickSort(0, nums.length - 1, nums);
  };
  ```

  

- 手写节流函数

  ```js
  function throttle(callback,interval=200){
      let tag=true;
      return function (){
          let that=this;
          if(!tag) return;
         	tag=false;
          setTimeout(()=>{
              callback.apply(that,arguments);
              tag=true;
          },interval);
      };
  }
  ```

- 手写防抖函数

  ```js
  fuction debounce(callback,delay){
      let timer=null;
      return fuction(){
          let that=this;
          clearTimeout(timer);
          timer=setTimeout(()=>{
              callback.apply(that,arguments)
          },delay)
  	}
  }
  ```

- vue diff算法：

  ```html
  <body>
      <div id="app">
      <input type="text" id="txt">
      <p id="show"></p>
  </div>
  </body>
  <script type="text/javascript">
  let obj={}
  Object.defineProperty(obj,'txt',{
      get(){
          return obj;
      },
      set(newValue){
          document.getElementById('txt').value=newValue;
          document.getElementById('show').innerHtml=newValue;
  	}
  })
  document.addEventListerner('keyup',fuction(e){
       obj.txt=e.target.value;
  })
  
  </script>
  ```

  

### DOM 操作常见API

```js
createDocumentFragment()
createElement()
createTextNode()

//添加 移除 替换 插入

appendChild()
removeChild()
replaceChild()
insertBefore()

//查找

getElementsByTagName()
getElementsByName()
getElementsByClassName()
getElementById()
querySelector()
querySelectorAll()
```

### JS设置css样式的几种方式

```js
/* 1.直接设置style属性 */
element.style.height = '100px';
/* 2.直接设置属性 */
element.setAttribute('height', '100px');
/* 3.使用setAttribute设置style属性 */
element.setAttribute('style', 'height: 100px !important');
/* 4.使用setProperty设置属性，通过第三个参数设置important */
element.style.setProperty('height', '300px', 'important');
/* 5.设置cssText */
element.style.cssText += 'height: 100px !important';
```

