---
layout:     post
title:      Javascript高程学习
subtitle:   本文是笔者学习Javascript的一些笔记。
date:       2018-04-15
author:     南三号
header-img: img/post-bg-js-version.jpg
catalog: true
tags:
    - Javascript
---

- 定义函数的方式：
  - 函数声明
  - 函数表达式（匿名函数）

- 函数声明提升
  - 函数声明总是在执行代码之前

- 函数表达式定义：先赋值再用

- 注意，JavaScript 只在一个线程上运行，不代表 JavaScript 引擎只有一个线程。事实上，JavaScript 引擎有多个线程，单个脚本只能在一个线程上运行（称为主线程），其他线程都是在后台配合。 

- 为了利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程，但是子线程完全受主线程控制，且不得操作 DOM。所以，这个新标准并没有改变 JavaScript 单线程的本质。  

- 事件循环机制：不停地检查，一遍又一遍，只要同步任务执行完了，引擎就会去检查那些挂起来的异步任务，是不是可以进入主线程了 

- 标签内不能出现标签的结束标签，否则浏览器会认为是结束的标签。如果要使用应添加转移字符`/`,例如`<\/script>`

- 延迟脚本会在加载到`<\html>`标签后进行下载，并且不一定会按照顺序加载，所以最好包含一个延迟脚本。

- 多个异步脚本的加载顺序并不会按照出现的先后顺序加载，所以必须保持多个异步脚本的互不依赖。

- noscript标签：当浏览器不支持JavaScript时显示标签内的内容。

- `undefined`值派生自`null`，所以null==undefined返回值为true

- NaN：not a number

- js函数参数数量不一定和函数定义的数量相同。

- 函数没有重载。

- 原型：
  - prototype属性保存了实例方法。
  - 每个函数都有两个非继承来的方法：apply和call
  - 都可以在特定的作用域内调用函数，即设置函数体内的this的值。区别在于参数的传入。最大的作用在于扩充函数运行的作用域。
  - bind方法：这个方法会创建一个函数的实例，其this值会被绑定到传给bind函数的值。

- toLocaleString( )和toString( )区别：
  - LocaleString()会根据你机器的本地环境来返回字符串，它和toString()返回的值在不同的本地环境下使用的符号可能变化；
  - 使用toString()是保险的方法，它不会因为本地环境（例如国家）改变而改变；
  - 一个常用的区别就是时间。为了返回时间类型的值的话，使用toLocaleString()；

- 所有Object类型包括其派生类型都会有一系列的原型属性和方法。而当使用基本类型值时，变量并不具有相应的原型属性和方法。但是我们却可以使用其原型属性和方法。原因在于在使用其原型属性或者方法时，后台会创建一个对应的基本类型的包装类实例，然后调用其原型方法后再销毁该实例。

  ```js
  let a =  "abc"
  console.log(a.length)
  
  //调用a.length会有如下后台过程
  let a = new String("abc")
  a.length
  a = null
  ```

- 字符串操作

  - 字符方法：接收一个参数放回该参数处的字符或者其字符编码。

    - charAt( )
    - charcodeAt( )

  - 字符串操作方法

    - 连接字符串（实际中使用更多的还是`+`）
      - concat( ) 

    - 截取字符串（接收一个参数时返回该参数开始到字符串结尾）
      - substr(a,b)    返回下标a开始长度为b的字符串，处理负数参数的方法为将第一个负数参数转化为0
      - substring(a,b)    返回下标a到b-1的字符串，处理负数参数的方法为将所有负值都转化为0
      - slice(a,b)    返回下标a到b-1的字符串，处理负数参数的方法为将负数参数与字符串长度相加。
    - 字符串位置(返回某个字符的下标)
      - indexof( )
      - lastIndexOf( )
    - 字符串大小写转换
      - toLowerCase( )
      - toUpperCase( )

#### BOM

- 客户端检测：
  - 能力检测
  - 怪癖检测
  - 用户代理检测（尽量使用前两种，Mozilla/5.x的故事可以了解一下）

#### DOM

- 在W3C对DOM事件进行规范化之前的事件处理，一般称为`DOM0级事件处理程序` ，DOM1级主要定义的是HTML和XML文档的底层结构。DOM2和DOM3级别则在这个结构的基础上引入了更多的交互能力，也支持了更高级的XML特性。为此DOM2和DOM3级分为许多模块（模块之间具有某种关联），分别描述了DOM的某个非常具体的子集。 

- 三个与网页请求有关的属性

  - URL（完整URL），不能修改

  - referrer（来源页面的URL），不能修改

  - domain（域名），可以修改，并且不能设置为URL中不包含的域，且只能由松散的到紧绷的，例如：

    ```js
    //页面来自于a.b.com
    //设置成b.com之后就不能设置为a.b.com了
    document.domain="b.com"		//松散的
    document.domain="a.b.com"		//紧绷的
    ```

- DOM特殊集合

- DOM一致性检测

  - 由于DOM分为多个级别，也包含多个部分，因此检测浏览器实现了哪些部分就很是必要。可以使用document.implementation对象。它还有一个方法hasFeature（），接收两个参数，要检测的功能名称和版本号。（但不推荐单独使用，因为早期一些浏览器没有实现功能也会有返回true的情况，推荐配合能力检测使用）

- 文档写入的四个方法：

  - write
  - writeln
  - open
  - close

#### 事件

- 事件流
  - 事件冒泡：由最深层次的节点逐级向外传播，一般事件冒泡到Windows对象
  - 事件捕获：由外层到内层

#### H5脚本编程

- 跨文档消息传递
- 原生拖放
- 媒体元素
- 历史状态管理

#### JSON

- JSON: JavaScript Object Notation(JavaScript 对象表示法)，JSON 是存储和交换文本信息的语法。类似 XML。JSON 比 XML 更小、更快，更易解析。

#### XML

- XML 指可扩展标记语言（eXtensible Markup Language）。XML 被设计用来传输和存储数据。
- XML 被设计用来传输和存储数据，其焦点是数据的内容。
- HTML 被设计用来显示数据，其焦点是数据的外观。

#### 高级技巧

- 测试js对象的类型，使用typeof和instance检测数据类型，有些时候往往会返回不如意的结果，可以用对象内置的toString方法。
- 作用域安全的构造函数（关于自定义对象新建实例new关键字的缺失会造成为全局对象绑定属性）
- 惰性载入函数：
  - 第一种方法：函数被调用时再处理，第一次调用时将函数覆盖为另一个符合条件的函数。
  - 第二种方法：在声明函数时就进行判断，一次赋值。
- 函数绑定：
- 函数柯里化：在数学和计算机科学中，柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。 
- 防篡改对象
- 不可扩展对象
- 密封的对象
- 冻结的对象
- 函数节流
- 自定义事件       

#### 离线应用与客户端缓存

- 即使网页应用在未联网时仍能够使用的技术

- 判断是否联网的方法：navigator.online

- 应用缓存：使用一个文件列出需要缓存的文件

  - 如果这个文件叫做a.manifest（描述文件以前推荐使用manifest，现在推荐使用appcache）

  - 将文件连接到页面上：

    ```html
    <html manifest="/a.manifest">
        
    </html>
    ```

  - 对应的对象：appcache

  - 





















