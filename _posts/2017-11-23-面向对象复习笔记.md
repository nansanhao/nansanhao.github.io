---
layout:     post
title:      面向对象复习笔记
subtitle:   本文是笔者课程学习的复习笔记。
date:       2017-11-23
author:     南三号
header-img: img/tag-bg-o.jpg
catalog: true
tags:
    - Java
    - 面向对象
---

### 初始值：

- 成员变量：自动拥有初始值0
- 局部变量：不会有初始值，所以要给初始值
- **特别注意：**
  同一方法不能有同名局部变量
  不同方法中可以有同名局部变量
  两类变量同名时，局部变量具有更高的优先级（就近原则）

### 静态方法：
- 注意：
   - 静态方法能直接调用同类中的静态变量，但不能调用非静态变量。想要调用必须先实例化一个对象。
   - 而普通方法则都可以调用。

### 静态初始化块
- 执行优先级：
  静态初始化块>初始化块>构造函数
- **注意：**
  静态初始化块只在加载类的时候加载一次，且只能初始化静态变量的值，不能初始化普通变量。

### final 关键字
- final修饰属性：
  该类的这个属性必须在属性初始化或者构造方法初始化的时候进行赋值(只能赋值一次，且只能而且必须在一处，要么属性初始化，要么构造方法，不能都进行赋值，也不能都不赋值，以前说属性会自动赋值0，但是加了final关键字之后就不会自动赋值)
- final修饰变量：
  只能在声明变量时进行赋值。(只能赋值一次)即变为常量。

### super关键字
- 意思：父类
- 注意：
  1、子类的构造方法中必须调用父类的构造方法。
  2、如果子类的构造方法没有显式调用父类的无参的构造方法，则系统默认调用父类无参的构造方法。
  3、如果显式调用父类构造方法，必须在子类构造方法的第一行。
  4、如果子类构造方法中没有显式调用父类的构造方法，因为会默认调用父类的无参构造方法，而如果父类定义了构 造方法而没有定义无参的构造方法，因为定义了有参所以系统不会自动生成一个无参的，所以会报错。
- **注意：**
  - 一个类只可以继承一个类（单继承），但一个类可以实现多个接口。（多继承）
  - 接口内容只有常量和抽象方法。
  - 系统会自动让接口变成抽象类，让接口内的方法变成抽象方法，让接口内的变量变成常量。

### 类的修饰符
- 分为：可访问控制符和非访问控制符两种。
   - 可访问控制符是: 公共类修饰符 public
   - 非访问控制符有：抽象类修饰符 abstract
   - 最终类修饰符：final

### UMl
- 用例图（Use Case Diagram）：从用户角度描述系统功能。
- 类图（Class Diagram）：描述对象模型中类与类之间的关系。
- 组件图（Component Diagram）：描述系统中各个组件之间的依赖关系，还可以描
  述组件的源代码组织结构。
- 部署图（Deployment Diagram）：定义系统中软硬件的物理体系结构。

### 类图
- · + ：表示public
- · - ：表示private
- · #：表示protected（friendly也归入这类）

### ⾯向对象中有⼀个重要原则『多⽤组合、少⽤继承』或者说『组合优于继承』。


### 不同包中相同名字的类的使用方法
```
import java.util.Date; 
import java.sql.*; 
java.util.Date deadLine = new java.util.Date();
java.sql.Date today = new java.sql.Date();
```



### 包
- 包名的声明必须出现在第一行;
- 默认包没有名称;
- 父包与子包：
- 子包需要显式引用
- 父包不包含子包

### 包装类的特点：
1. 所有的包装类都是final类型，不能创建子类
2. 包装类是不可变类，不可强制转换

### 字符串的split参数

### 泛型潜在问题
- 潜在问题一
  如果Foo是Bar的⼦类型（⼦类或接⼝实现类），G是⼀个泛型类，
  那么G<Foo>并不是G<Bar>的⼦类型。
- 潜在问题⼆
  drawAll只能接受
  List<Shape>，不能够接受
  Shape⼦类的数组。

### 通配符相关用法
### [通配符的一个注意点](http://m.blog.csdn.net/baple/article/details/25056169)

### Hash集合要求两个对象用equals()方法比较的结果为true时，它们的哈希码也相等。

### 异常处理原则
1. 避免过大的try语句块；
2. 细化异常的类型，不要都用Exception；
3. 自己能处理的异常不要抛给别人；
4. 不要用try-catch实现控制流程的跳转；
5. 尽可能重用已经存在的异常类。
6. try语句块不能单独存在，catch语句块可以有一个或多个，finally语句块最多一个；
7. try-catch-finally均不能单独使用；
8. 有多个catch块时，Java会按顺序匹配，如找到匹配则不会继续执行后面的catch；
9. throw语句后的语句不会被执行

